<!doctype html>
<style>
  body { background: rgb(225, 221, 196); }
  pre { margin: 0; border: 1px solid rgb(150,150,150) }
</style>

<pre id="myterm"></pre>
<input type="text" class="tib" placeholder="tib" size="80">

<script src="jquery-1.11.3.js"></script>
<script>
"use strict"
var mem = [] // memory map

////////////////////// javascript io hookups ?
function packstr( adr, tok ){
	var cell = tok.length
	for( var i = 1; i < parseInt( (tok.length + 4)/4 ) * 4; i ++ ){// 4 bytes / cell
		cell <<= 8
		cell |= i < tok.length + 1 ? tok.charCodeAt( i - 1 ) : 0 // backfill 0's
		if( i % 4 === 3 ){// next cell ?
			mem[ adr ++ ] = cell
			cell = 0
		}// if
	} return adr
}// packstr	
function str( adr ){
	var cell = mem[ adr ++ ], n = cell >> 24
	var s = ""; for( var i = 1; i < n + 1; i ++ ){
		s += String.fromCharCode( cell >> 8 * ( 3 - i % 4 ) & 0xff )
		if( i % 4 === 3 ){// next cell ?
			cell = mem[ adr ++ ]
		}// if
	} return s
}// str	

var sp, rp // special variables - more like cpu registers ?

//////////////////////////// execute tokens ?
// The code address indicates code to be executed depending on word type:
// . VARIABLE words
// . CONSTANT words
// . colon-definition USER words
// . DOES> words
// . CODE-definition assembler words
function variable(){// next parm value on stack
	debugger
	mem[ sp ++ ] = mem[ mem[ rp - 1 ] + 1 ]
}
function primitive(){// next parm cfa call
	debugger
	mem[ mem[ rp - 1 ] + 1 ]()
}
function colondef(){// call parm list
	debugger
	while( 1 ){
		mem[ ++ mem[ rp - 1 ] ]() // next parm cfa call, incremetn ip
		if( fexit || fabort || fexpect ){
			if( fexit || fabort ){
				rp -- // pop return stack
				fexit = 0
			}
			break
		}// if exit abort expect
	}// while 1
}// colondef

var xhere = 1, xlatest = 0 // end-of-list marker is 0
function defword( tok, lnk, plist ){
	var nfa = xhere
	xhere = packstr( xhere, tok )
	mem[ xhere ++ ] = lnk
	for( var i = 0; i < plist.length; i ++ ){
		mem[ xhere ++ ] = plist[ i ]
	}// for
	return nfa
}// defword

/////////////////////////////// variables ?
xlatest = defword( "sp0", xlatest, [ variable, 300 ]); var s0ptr = xlatest + 3
xlatest = defword( "rp0", xlatest, [ variable, 400 ]); var r0ptr = xlatest + 3
xlatest = defword( "tib0", xlatest, [ variable, 500 ]); var tib0ptr = xlatest + 4
xlatest = defword( "latest", xlatest, [ variable, 0 ]); var latestptr = xlatest + 4
xlatest = defword( "here", xlatest, [ variable, 0 ]); var hereptr = xlatest + 4
xlatest = defword( "base", xlatest, [ variable, 10 ]); var baseptr = xlatest + 4
//latest = defword( "state", latest, [ variable, 0 ])
function TIB0() { mem[ sp ++ ] = tib0ptr }// ( --- pfa )
function LATEST(){ mem[ sp ++ ] = latestptr }// ( --- pfa )
function BASE(){ mem[ sp ++ ] = baseptr }// ( --- pfa )

//////////////////////////// other primitives ?
var my_jstib = [] // javascript array tib, text input buf
var fexit = 0, fabort = 0, fexpect = 0
function EXECUTE(){ // ( cfa --- )
	debugger
	mem[
		mem[ rp ++ ] = mem[ -- sp ] // >r "to-r"
	]() // and away...
}// EXECUTE
function LIT(){ // ( --- lit ) from next ip ?
	debugger
	mem[ sp ++ ] = mem[ ++ mem[ rp - 1 ] ]
}
function EXIT(){ fexit ++ }
// function KEY(){// ( --- char )
// 	function key_handler(e){
// 		mem[ sp ++ ] = e.charCode
// 		fexpect = 0
// 		$('input.tib').off('.mytib').on( 'keypress.mytib', monitor_handler )
// 		$('pre#myterm')[0].innerText += " ok "
// 		return false // don't show key
// 	}// key_handler
// 	fexpect = 1
// 	$('input.tib').off('.mytib').on( 'keypress.mytib', key_handler )
// }// KEY
function WORD(){// ( delim --- )
	var delim = mem[ -- sp ], my_word = ""
	function word_handler(e){
		debugger
		if( e.charCode === delim ){// reached n or CR ?
			if( my_word.length ){// got word ?
				packstr( mem[ tib0ptr ], my_word )
				fexpect = 0
				if( rp > mem[ r0ptr ] ){// restart return stack ip ?
					colondef()
				} else {// back to monitor
					$('pre#myterm')[0].innerText += " ok "
					$('input.tib').off('.mytib').on( 'keypress.mytib', monitor_handler )
				}// if return stack
			}// if word
		} else {// accumulate chars
			var c = String.fromCharCode( e.charCode )
			my_word += c
			$('pre#myterm')[0].innerText += c
		}// if delim
		return false // don't show key in input element, show in myterm
	}// word_handler
	
	if( my_jstib.length ){// tok in js array ?
		packstr( mem[ tib0ptr ], my_jstib.shift() )
		fexpect = 0
	} else {// wait for input
		fexpect = 1
		$('input.tib').off('.mytib').on( 'keypress.mytib', word_handler )
	}// if
}// WORD
// function EXPECT(){// ( adr n --- )
// 	fexpect = mem[ -- sp ] // n limit
// 	var adr = mem[ -- sp ]
// 	function expect_handler(e){
// 		fexpect --
// 		if( fexpect === 0 || e.charCode === 13 ){// reached n or CR ?
// 			if( fexpect ){// got CR ?
// 				fexpect = 0
// 			} else {// n limit ?
// 				$('pre#myterm')[0].innerText += String.fromCharCode(
// 					mem[ adr ++ ] = e.charCode
// 				)
// 			} mem[ adr ] = 0 // terminaten
// 			if( rp > rp0 ){// restart ip (on return stack)
// 				colondef()
// 			} else {// back to monitor
// 				$('input.tib').off('.mytib').on( 'keypress.mytib', monitor_handler )
// 				$('pre#myterm')[0].innerText += " ok "
// 			}// if
// 		} else {// expectn keys
// 			$('pre#myterm')[0].innerText += String.fromCharCode(
// 				mem[ adr ++ ] = e.charCode
// 			)
// 		}// if
// 		return false // don't show key in input element, show in myterm
// 	}// expect_handler
// 	if( my_jstib.length ){// got tok ?
// 		var tok = my_jstib.shift()
// 		for( var i = 0; i < tok.length; i ++ ){
// 			mem[ adr ++ ] = tok.charAt( i )
// 		} mem[ adr ] = 0 // terminatr
// 		fexpect = 0
// 	} else {// wait for input
// 		$('input.tib').off('.mytib').on( 'keypress.mytib', expect_handler )
// 	}
// }// EXPECT

function FETCH(){// ( adr --- n )
	mem[ sp - 1 ] = mem[ mem[ sp - 1 ] ]
}
//function STORE(){ mem[ mem[ sp - 1 ] ] = mem[ sp - 2 ]; sp -= 2 }// ( n adr --- )
//function CR(){ $('pre#myterm')[0].innerText += '\n' }
function ZBRANCH(){// ( flag --- )
	if( !mem[ -- sp ] ){
		mem[ rp - 1 ] += mem[ ++ mem[ rp - 1 ] ] // next parm, branch offset
	} mem[ rp - 1 ] ++ // skip branch offset parm
}// ZBRANCH
function DOT_S(){
	debugger
	var n = sp - mem[ s0ptr ]; if( n ){
		for( var i = 0; i < n; i ++ ){
			$('pre#myterm')[0].innerText +=
				mem[ sp - 1 - i ].toString( mem[ baseptr ] ) + '\n'
		}// for
	} else {
		$('pre#myterm')[0].innerText += " empty "
	}// if
}// DOT_S

// : decade  10 0 do  i .  loop ;
// which executes like this: decade <ret> 0 1 2 3 4 5 6 7 8 9 ok

function DUP(){	mem[ sp ++ ] = mem[ sp - 1 ] } // ( n --- n n )
function POP(){	sp -- } // ( n --- )
// There are five FORTH words concerned with finding the address of the various word fields. They are:
// 1) ' ( tick)
// 2) PFAPTR ( Parameter Field Pointer Address) - ?RSC-FORTH User's guide
// 3) CFA ( Code Field Address)
// 4) LFA ( Link Field Address)
// 5) NFA ( Name Field Address)

// cell  | byt0|  1  |  2  |  3  | description
// ------+-----+-----+-----+-----+------------
// nfa 0 |  4  |  d  |  a  |  t  | count-byte 'n' & name
//     1 |  e  |  0  |  0  |  0  | "date"
// lfa 2 | previous nfa, 0 eol   | link
// cfa 3 |                       | code
// pfa 4 | data                  | parameter
function PFA(){ // ( nfa --- pfa )
	var n = mem[ mem[ sp - 1 ] ] >> 24 & 0x1f
	mem[ sp - 1 ] += parseInt( ( n + 4 ) / 4 ) + 2
}
function CFA(){	mem[ sp - 1 ] -- } // ( pfa --- cfa )
function FIND()
{	// adr1 adr2 --- pfa count-byte tf (ok)
	// adr1 adr2 --- ff (?)
	var adr2 = mem[ -- sp ], adr1 = mem[ -- sp ]
	var n1 = mem[ adr1 ] >> 24 & 0x1f, s1 = str( adr1 )
	do {
		var n2 = mem[ adr2 ] >> 24 & 0x1f
		if( n2 === n1 ){ // count hit ?
			if( str( adr2 ) === s1 ){
				mem[ sp ++ ] = adr2 // nfa
				PFA() // ( nfa --- pfa )
				mem[ sp ++ ] = n2 // count byte
				mem[ sp ++ ] = true
				return
			}// if str
		}// if n
	} while( adr2 = mem[ adr2 + parseInt( ( n2 + 4 ) / 4 ) ] ) // lnk
	mem[ sp ++ ] = false
}// FIND
function ABORT(){
	sp = mem[ s0ptr ] // reset stack
	fabort ++
}
function NUMBER(){ // ( addr --- d )
	var s = str( mem[ -- sp ] ),  d = parseInt( s, mem[ baseptr ] )
	if( isNaN( d ) ){
		ABORT()
	} else {
		mem[ sp ++ ] = d
	}// if NaN
}// NUMBER
xlatest = defword( ".s", xlatest, [ primitive, DOT_S ])
xlatest = defword( "execute", xlatest, [ primitive, EXECUTE ])
//latest = defword( "hex", latest, [ colondef, LIT, 16, TICK, "base", STORE, EXIT ])
//latest = defword( "decimal", latest, [ DECIMAL ])
//latest = defword( "@", latest, [ primitive, FETCH ])
//latest = defword( "!", latest, [ primitive, STORE ])
//latest = defword( "cr", latest, [ primitive, CR ])
//latest = defword( "expect", latest, [ primitive, EXPECT ])

function monitor_handler( e ){

	function evl(){
		while( my_jstib.length ){
			packstr( mem[ tib0ptr ], my_jstib.shift() ) // from javascript array ?
			mem[ sp ++ ] = mem[ tib0ptr ]
			fexpect = 0 // clearn ?
			if( rp > mem[ r0ptr ] ){// ip on return stack ?
				colondef()
			} else {// dictionary lookup
				mem[ sp ++ ] = mem[ latestptr ]
				FIND() // ( a1 a2 --- pfa n tf ) or ( a1 a2 --- ff )
				if( mem[ -- sp ] ){
					var n = mem[ -- sp ] // count byte
					CFA() // ( pfa --- cfa )
					EXECUTE() // ( cfa --- )
				} else {
					mem[ sp ++ ] = mem[ tib0ptr ]
					NUMBER() // ( a1 --- d )
				}// if
			}// if rp
			if( fabort ){
				my_jstib.length = 0 // clear js input array ?
			}
		}// while jstib.length
	}// evl

	if( e.which === 13 ){ // return key
		$('pre#myterm')[0].innerText += this.value + '\n' // appendn
		my_jstib = this.value.split(/\s/).filter(Boolean)
		this.value = null
		evl()
		$('pre#myterm')[0].innerText += fabort ? (
			" ? " + str( mem[ tib0ptr ] ) + " "
		): " ok "
		fabort = 0
	}// if return
}// monitor_handler


//////////////////////////// colon definitions ?
xlatest = defword( "'", xlatest, [
	colondef,
	LIT, ' ', WORD,
	TIB0, FETCH, LATEST, FETCH, FIND,
	ZBRANCH, 2, POP, EXIT, ABORT
])

// Enter some numbers on the stack and display the stack contents.
// 678 356
// .S
// 356
// 678 OK
// Type Q now and verify that the stack is cleared.
// Q
// Q ? .S
// EMPTY OK
// KEY <RETURN> A ( Type A) .S
// 41
// HEX 600 OK
// DECIMAL OK
// 15 CR EXPECT
// 1234567890123450K
// HEX 600 10 DUMP
// 600 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 0
// OK
//                                 <--- todo: i'm here
// : TEST-OP 5 * . ; <RETURN> OK
// ' TEST-OP <RETURN> OK
// .S
// 432 OK
$( document ).ready( function(){
	mem[ latestptr ] = xlatest
	mem[ hereptr ] = xhere
	sp = mem[ s0ptr ]
	rp = mem[ r0ptr ]
	$( 'input.tib' ).off('.mytib').on( 'keypress.mytib', monitor_handler ).focus()
	$('pre#myterm')[0].innerText += " ok "
}) // ready
</script>

