<!doctype html>
<style>
  body { background: rgb(225, 221, 196); }
  pre { margin: 0; border: 1px solid rgb(150,150,150) }
</style>

<pre id="myterm"></pre>
<input type="text" class="tib" placeholder="tib" size="80">

<pre class="s0"></pre>
<pre class="c0"></pre>

<script src="jquery-1.11.3.js"></script>
<script>
"use strict"
var mem = [] // memory map
var sp0 = 300, sp = sp0 // parameter stack
var rp0 = 400, rp = rp0 // parameter stack
var tib0 = 500; function TIB() { mem[ sp ++ ] = tib0 }// ( --- tib )
var latest = 0; function LATEST(){ mem[ sp ++ ] = latest }// ( --- adr )
var here = 1 // 0 reserved for end-of-list marker
function HERE(){ mem[ sp ++ ] = here }// ( --- adr )

// The words:
// : (colon), POSTPONE, ' (tick)
// are examples of parsing words that take their arguments from the user input device instead of the data stack.

var fexit = 0, fabort = 0, fexpect = 0
//var fcreate = 0, ftick = 0, fcolon = 0, fliteral = 0
// function create(){ fcreate ++ }
// function colon(){ fcolon = 1 }

function pushstr( pt, tok ){
	var cell = tok.length
	for( var i = 1; i < parseInt( (tok.length + 4)/4 ) * 4; i ++ ){
		cell <<= 8
		cell |= i < tok.length + 1 ? tok.charCodeAt( i - 1 ) : 0
		if( i % 4 === 3 ){
			mem[ pt ++ ] = cell
			cell = 0
		}// if
	} return pt
}// pushstr	
function str( adr ){
	var cell = mem[ adr ++ ], n = cell >> 24
	var s = ""; for( var i = 1; i < n + 1; i ++ ){
		s += String.fromCharCode( ( cell >> ( 3 - i ) * 8 ) & 0xff )
		if( i % 4 === 3 ){
			cell = mem[ adr ++ ]
		}// if
	} return s
}// str	
function DOT_S(){
	var n = sp - sp0; if( n ){
		for( var i = 0; i < n; i ++ ){
			$('pre#myterm')[0].innerText += mem[ sp - 1 - i ]
				.toString( mem[ my_base ] ) + '\n'
		}// for
	} else {
		$('pre#myterm')[0].innerText += " empty "
	}// if
}// DOT_S

// : decade  10 0 do  i .  loop ;
// which executes like this: decade <ret> 0 1 2 3 4 5 6 7 8 9 ok

function DUP(){	mem[ sp ++ ] = mem[ sp - 1 ] } // ( n --- n n )
// There are five FORTH words concerned with finding the address of the various word fields. They are:
// 1) ' ( tick)
// 2) PFAPTR ( Parameter Field Pointer Address) - ?RSC-FORTH User's guide
// 3) CFA ( Code Field Address)
// 4) LFA ( Link Field Address)
// 5) NFA ( Name Field Address)

// cell  | byt0|  1  |  2  |  3  | description
// ------+-----+-----+-----+-----+------------
// nfa 0 |  4  |  d  |  a  |  t  | count-byte 'n' & name
//     1 |  e  |  0  |  0  |  0  | "date"
// lfa 2 | previous nfa, 0 eol   | link
// cfa 3 |                       | code
// pfa 4 | data                  | parameter
function PFA(){ // ( nfa --- pfa )
	var nfa = mem[ sp - 1 ], n = mem[ nfa ] >> 24 & 0x1f
	mem[ sp - 1 ] += parseInt( ( n + 4 ) / 4 ) + 2
}
function CFA(){	mem[ sp - 1 ] -= 1 } // ( pfa --- cfa )
function FIND()
{	// adr1 adr2 --- pfa count-byte tf (ok)
	// adr1 adr2 --- ff (?)
	var adr2 = mem[ -- sp ], adr1 = mem[ -- sp ]
	var n1 = mem[ adr1 ] >> 24 & 0x1f, s1 = str( adr1 )
	do {
		var n2 = mem[ adr2 ] >> 24 & 0x1f
		if( n2 === n1 ){ // count hit ?
			if( str( adr2 ) === s1 ){
				mem[ sp ++ ] = adr2 // nfa
				PFA() // ( nfa --- pfa )
				mem[ sp ++ ] = n2 // count byte
				mem[ sp ++ ] = true
				return
			}// if str
		}// if n
	} while( adr2 = mem[ adr2 + parseInt( ( n2 + 4 ) / 4 ) ] ) // lnk
	mem[ sp ++ ] = false
}// FIND
function ABORT(){
	sp = sp0 // reset stack
	fabort ++
}
function NUMBER(){ // ( addr --- d )
	var s = str( mem[ -- sp ] ),  d = parseInt( s, mem[ my_base ] )
	if( isNaN( d ) ){
		ABORT()
	} else {
		mem[ sp ++ ] = d
	}// if NaN
}// NUMBER
function dump(){
	$('pre.s0').empty().text(
		$.map( Array( sp - sp0 ), function( v, i ){
			return [ sp - 1 - i , mem[ sp - 1 - i ] ].join(": ")
		}).join('\n')
	)// text
}// dump
var my_jstib = [] // javascript array tib, text input buf
function monitor_handler( e ){
	if( e.which === 13 ){ // return key
		$('pre#myterm')[0].innerText += this.value + '\n' // appendn
		my_jstib = this.value.split(/\s/).filter(Boolean)
		this.value = null
		evl()
		if( fabort ){
			$('pre#myterm')[0].innerText += " ? "
			fabort = 0
		} else {
			if( fexpect ){
				debugger
			} else {
				$('pre#myterm')[0].innerText += " ok "
			}// if expect
		}// if abort
	}// if return
}// monitor_handler
function KEY(){// ( --- char )
	function key_handler(e){
		mem[ sp ++ ] = e.charCode
		fexpect = 0
		$('input.tib').off('.mytib').on( 'keypress.mytib', monitor_handler )
		$('pre#myterm')[0].innerText += " ok "
		return false // don't show key
	}// key_handler
	fexpect = 1
	$('input.tib').off('.mytib').on( 'keypress.mytib', key_handler )
}// KEY
function EXPECT(){// ( adr n --- )
	fexpect = mem[ -- sp ]
	var adr = mem[ -- sp ]
	function expect_handler(e){
		fexpect --
		if( fexpect === 0 || e.charCode === 13 ){// reached n or CR ?
			if( fexpect ){// got CR ?
				fexpect = 0
			} else {// got n char codes
				$('pre#myterm')[0].innerText += String.fromCharCode(
					mem[ adr ++ ] = e.charCode
				)
			}// if
			mem[ adr ++ ] = 0 // terminaten
			debugger
			if( rp > rp0 ){// restart ip (on return stack)
				colondef()
			} else {// back to monitor
				$('input.tib').off('.mytib').on( 'keypress.mytib', monitor_handler )
				$('pre#myterm')[0].innerText += " ok "
			}// if
		} else {
			$('pre#myterm')[0].innerText += String.fromCharCode(
				mem[ adr ++ ] = e.charCode
			)
		}// if
		return false // don't show key in input element, show in myterm
	}// expect_handler
	$('input.tib').off('.mytib').on( 'keypress.mytib', expect_handler )
}// EXPECT

function EXECUTE(){ // ( cfa --- )
	// The code address indicates code to be executed depending on word type:
	// . colon-definition USER words
	// . VARIABLE words
	// . CONSTANT words
	// . DOES> words
	// . CODE-definition assembler words
	mem[
		mem[ rp ++ ] = mem[ -- sp ] // >rp, init return stack
	]() // and away...
}// EXECUTE
function colondef(){ // run cfa's in parm list ?
	debugger
	while( 1 ){
		mem[
			++ mem[ rp - 1 ] // incrementn ip, on top of return stack ?
		]()
		if( fexit ){
			rp -- // pop return stack
			fexit = 0
			break
		} else {
			if( fexpect ){// input ?
				break
			}// if expect
		}// if exit
	}// while 1
}// colondef
function LIT(){
	mem[ sp ++ ] = mem[
		++ mem[ rp - 1 ] // literal at next ip ?
	]
}// LIT
function EXIT(){ fexit ++ }
function variable( cfa ){ mem[ sp ++ ] = cfa + 1 }
function constant( cfa ){ mem[ sp ++ ] = mem[ cfa + 1 ] }
function FETCH(){// ( adr --- n )
	mem[ sp - 1 ] = mem[ mem[ sp - 1 ] ]
}
function STORE(){// ( n adr --- )
	mem[ mem[ sp - 1 ] ] = mem[ sp - 2 ]; sp -= 2
}
function CR(){ $('pre#myterm')[0].innerText += '\n' }

function defword( tok, lnk, plist ){
	var nfa = here
	here = pushstr( here, tok )
	mem[ here ++ ] = lnk
	for( var i = 0; i < plist.length; i ++ ){
		mem[ here ++ ] = plist[ i ]
	}// for
	return nfa
}// defword
latest = defword( "latest", latest, [ LATEST ])
latest = defword( "here", latest, [ HERE ])
latest = defword( ".s", latest, [ DOT_S ])
latest = defword( "key", latest, [ KEY ])
latest = defword( "base", latest, [ variable, 0 ])
// latest = defword( "hex", latest, [ colondef, LIT, 16, TICK, "base", STORE, EXIT ])
// latest = defword( "decimal", latest, [ DECIMAL ])
latest = defword( "@", latest, [ FETCH ])
latest = defword( "!", latest, [ STORE ])
latest = defword( "cr", latest, [ CR ])
latest = defword( "expect", latest, [ EXPECT ])
latest = defword( "'", latest, [
	colondef, TIB, LIT, 31, EXPECT, LATEST, FIND, EXIT
])
latest = defword( "state", latest, [ variable, 0 ])

function evl(){
	while( my_jstib.length ){
		pushstr(tib0, my_jstib.shift() ) // loadn tib from javascript array ?
		mem[ sp ++ ] = tib0 // text input buffer
		fexpect = 0 // clearn ?
		if( rp > rp0 ){// ip on return stack ?
			colondef()
		} else {// dictionary lookup
			mem[ sp ++ ] = latest // dictionary nfa
			FIND() // ( a1 a2 --- pfa n tf ) or ( a1 a2 --- ff )
			if( mem[ -- sp ] ){
				var n = mem[ -- sp ] // count byte
				CFA() // ( pfa --- cfa )
				EXECUTE() // ( cfa --- )
			} else {
				mem[ sp ++ ] = tib0
				NUMBER() // ( a1 --- d )
			}// if
		}// if rp
		if( fabort ){
			my_jstib.length = 0 // clear js input array ?
			fabort = 0
			break
		}// if abort
	}// while jstib.length
}// evl

// Enter some numbers on the stack and display the stack contents.
// 678 356
// .S
// 356
// 678 OK
// Type Q now and verify that the stack is cleared.
// Q
// Q ? .S
// EMPTY OK
// KEY <RETURN> A ( Type A) .S
// 41
// HEX 600 OK
// DECIMAL OK
// 15 CR EXPECT
// 1234567890123450K
// HEX 600 10 DUMP
// 600 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 0
// OK
//                                 <--- todo: i'm here
// : TEST-OP 5 * . ; <RETURN> OK
// ' TEST-OP <RETURN> OK
// .S
// 432 OK
$( document ).ready( function(){
	dump()
	$( 'input.tib' ).off('.mytib').on( 'keypress.mytib', monitor_handler ).focus()
	$('pre#myterm')[0].innerText += " ok "
}) // ready
</script>

